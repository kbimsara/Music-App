{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useState as $3pPTd$useState } from \"react\";\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  var _options$initialItems = options.initialItems,\n    initialItems = _options$initialItems === void 0 ? [] : _options$initialItems,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey = options.getKey,\n    getKey = _options$getKey === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey,\n    _options$getChildren = options.getChildren,\n    getChildren = _options$getChildren === void 0 ? function (item) {\n      return item.children;\n    } : _options$getChildren;\n  var _ref = (0, $3pPTd$useState)(function () {\n      return buildTree(initialItems, new Map());\n    }),\n    _ref2 = _slicedToArray(_ref, 2),\n    tree = _ref2[0],\n    setItems = _ref2[1];\n  var items = tree.items,\n    nodeMap = tree.nodeMap;\n  var _ref3 = (0, $3pPTd$useState)(new Set(initialSelectedKeys || [])),\n    _ref4 = _slicedToArray(_ref3, 2),\n    selectedKeys = _ref4[0],\n    setSelectedKeys = _ref4[1];\n  function buildTree() {\n    var initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var map = arguments.length > 1 ? arguments[1] : undefined;\n    var parentKey = arguments.length > 2 ? arguments[2] : undefined;\n    return {\n      items: initialItems.map(function (item) {\n        var node = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n  function updateTree(items, key, update, originalMap) {\n    var node = originalMap.get(key);\n    if (!node) return {\n      items: items,\n      nodeMap: originalMap\n    };\n    var map = new Map(originalMap);\n    var newNode = update(node);\n    if (newNode == null) deleteNode(node, map);else addNode(newNode, map);\n    while (node.parentKey) {\n      var nextParent = map.get(node.parentKey);\n      var copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      var children = nextParent.children;\n      if (newNode == null) children = children.filter(function (c) {\n        return c !== node;\n      });\n      copy.children = children.map(function (child) {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(function (c) {\n      return c !== node;\n    });\n    return {\n      items: items.map(function (item) {\n        if (item === node) return newNode;\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n  function addNode(node, map) {\n    map.set(node.key, node);\n    for (var child of node.children) addNode(child, map);\n  }\n  function deleteNode(node, map) {\n    map.delete(node.key);\n    for (var child of node.children) deleteNode(child, map);\n  }\n  return {\n    items: items,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem: function getItem(key) {\n      return nodeMap.get(key);\n    },\n    insert: function insert(parentKey, index) {\n      for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        values[_key - 2] = arguments[_key];\n      }\n      setItems(function (_ref5) {\n        var items = _ref5.items,\n          originalMap = _ref5.nodeMap;\n        var _buildTree = buildTree(values, originalMap, parentKey),\n          newNodes = _buildTree.items,\n          newMap = _buildTree.nodeMap;\n        if (parentKey == null) return {\n          items: [].concat(_toConsumableArray(items.slice(0, index)), _toConsumableArray(newNodes), _toConsumableArray(items.slice(index))),\n          nodeMap: newMap\n        };\n        return updateTree(items, parentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(newNodes), _toConsumableArray(parentNode.children.slice(index)))\n          };\n        }, newMap);\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      var node = nodeMap.get(key);\n      if (!node) return;\n      var parentNode = nodeMap.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items;\n      var index = nodes.indexOf(node);\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index].concat(values));\n    },\n    insertAfter: function insertAfter(key) {\n      var node = nodeMap.get(key);\n      if (!node) return;\n      var parentNode = nodeMap.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items;\n      var index = nodes.indexOf(node);\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1].concat(values));\n    },\n    prepend: function prepend(parentKey) {\n      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        values[_key4 - 1] = arguments[_key4];\n      }\n      this.insert.apply(this, [parentKey, 0].concat(values));\n    },\n    append: function append(parentKey) {\n      for (var _len5 = arguments.length, values = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        values[_key5 - 1] = arguments[_key5];\n      }\n      if (parentKey == null) this.insert.apply(this, [null, items.length].concat(values));else {\n        var parentNode = nodeMap.get(parentKey);\n        if (!parentNode) return;\n        this.insert.apply(this, [parentKey, parentNode.children.length].concat(values));\n      }\n    },\n    remove: function remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      if (keys.length === 0) return;\n      var newItems = items;\n      var prevMap = nodeMap;\n      var newTree;\n      for (var key of keys) {\n        newTree = updateTree(newItems, key, function () {\n          return null;\n        }, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n      setItems(newTree);\n      var selection = new Set(selectedKeys);\n      for (var _key7 of selectedKeys) if (!newTree.nodeMap.has(_key7)) selection.delete(_key7);\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      this.remove.apply(this, _toConsumableArray(selectedKeys));\n    },\n    move: function move(key, toParentKey, index) {\n      setItems(function (_ref6) {\n        var items = _ref6.items,\n          originalMap = _ref6.nodeMap;\n        var node = originalMap.get(key);\n        if (!node) return {\n          items: items,\n          nodeMap: originalMap\n        };\n        var _updateTree = updateTree(items, key, function () {\n            return null;\n          }, originalMap),\n          newItems = _updateTree.items,\n          newMap = _updateTree.nodeMap;\n        var movedNode = _objectSpread(_objectSpread({}, node), {}, {\n          parentKey: toParentKey\n        });\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {\n            items: [].concat(_toConsumableArray(newItems.slice(0, index)), [movedNode], _toConsumableArray(newItems.slice(index))),\n            nodeMap: newMap\n          };\n        }\n        return updateTree(newItems, toParentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), [movedNode], _toConsumableArray(parentNode.children.slice(index)))\n          };\n        }, newMap);\n      });\n    },\n    update: function update(oldKey, newValue) {\n      setItems(function (_ref7) {\n        var items = _ref7.items,\n          originalMap = _ref7.nodeMap;\n        return updateTree(items, oldKey, function (oldNode) {\n          var node = {\n            key: oldNode.key,\n            parentKey: oldNode.parentKey,\n            value: newValue,\n            children: null\n          };\n          var tree = buildTree(getChildren(newValue), originalMap, node.key);\n          node.children = tree.items;\n          return node;\n        }, originalMap);\n      });\n    }\n  };\n}\nexport { $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData };","map":{"version":3,"names":["useState","$3pPTd$useState","$be2ea0343af54212$export$d14e1352e21f4a16","options","_options$initialItems","initialItems","initialSelectedKeys","_options$getKey","getKey","item","id","key","_options$getChildren","getChildren","children","_ref","buildTree","Map","_ref2","_slicedToArray","tree","setItems","items","nodeMap","_ref3","Set","_ref4","selectedKeys","setSelectedKeys","arguments","length","undefined","map","parentKey","node","value","set","updateTree","update","originalMap","get","newNode","deleteNode","addNode","nextParent","copy","filter","c","child","delete","getItem","insert","index","_len","values","Array","_key","_ref5","_buildTree","newNodes","newMap","concat","_toConsumableArray","slice","parentNode","insertBefore","nodes","indexOf","_len2","_key2","apply","insertAfter","_len3","_key3","prepend","_len4","_key4","append","_len5","_key5","remove","_len6","keys","_key6","newItems","prevMap","newTree","selection","has","removeSelectedItems","move","toParentKey","_ref6","_updateTree","movedNode","_objectSpread","oldKey","newValue","_ref7","oldNode","useTreeData"],"sources":["D:/React Native/Expo+glustack/Music-App/node_modules/@react-stately/data/dist/useTreeData.mjs"],"sourcesContent":["import {useState as $3pPTd$useState} from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n    let { initialItems: initialItems = [], initialSelectedKeys: initialSelectedKeys, getKey: getKey = (item)=>item.id || item.key, getChildren: getChildren = (item)=>item.children } = options;\n    // We only want to compute this on initial render.\n    let [tree, setItems] = (0, $3pPTd$useState)(()=>buildTree(initialItems, new Map()));\n    let { items: items, nodeMap: nodeMap } = tree;\n    let [selectedKeys, setSelectedKeys] = (0, $3pPTd$useState)(new Set(initialSelectedKeys || []));\n    function buildTree(initialItems = [], map, parentKey) {\n        return {\n            items: initialItems.map((item)=>{\n                let node = {\n                    key: getKey(item),\n                    parentKey: parentKey,\n                    value: item,\n                    children: null\n                };\n                node.children = buildTree(getChildren(item), map, node.key).items;\n                map.set(node.key, node);\n                return node;\n            }),\n            nodeMap: map\n        };\n    }\n    function updateTree(items, key, update, originalMap) {\n        let node = originalMap.get(key);\n        if (!node) return {\n            items: items,\n            nodeMap: originalMap\n        };\n        let map = new Map(originalMap);\n        // Create a new node. If null, then delete the node, otherwise replace.\n        let newNode = update(node);\n        if (newNode == null) deleteNode(node, map);\n        else addNode(newNode, map);\n        // Walk up the tree and update each parent to refer to the new children.\n        while(node.parentKey){\n            let nextParent = map.get(node.parentKey);\n            let copy = {\n                key: nextParent.key,\n                parentKey: nextParent.parentKey,\n                value: nextParent.value,\n                children: null\n            };\n            let children = nextParent.children;\n            if (newNode == null) children = children.filter((c)=>c !== node);\n            copy.children = children.map((child)=>{\n                if (child === node) return newNode;\n                return child;\n            });\n            map.set(copy.key, copy);\n            newNode = copy;\n            node = nextParent;\n        }\n        if (newNode == null) items = items.filter((c)=>c !== node);\n        return {\n            items: items.map((item)=>{\n                if (item === node) return newNode;\n                return item;\n            }),\n            nodeMap: map\n        };\n    }\n    function addNode(node, map) {\n        map.set(node.key, node);\n        for (let child of node.children)addNode(child, map);\n    }\n    function deleteNode(node, map) {\n        map.delete(node.key);\n        for (let child of node.children)deleteNode(child, map);\n    }\n    return {\n        items: items,\n        selectedKeys: selectedKeys,\n        setSelectedKeys: setSelectedKeys,\n        getItem (key) {\n            return nodeMap.get(key);\n        },\n        insert (parentKey, index, ...values) {\n            setItems(({ items: items, nodeMap: originalMap })=>{\n                let { items: newNodes, nodeMap: newMap } = buildTree(values, originalMap, parentKey);\n                // If parentKey is null, insert into the root.\n                if (parentKey == null) return {\n                    items: [\n                        ...items.slice(0, index),\n                        ...newNodes,\n                        ...items.slice(index)\n                    ],\n                    nodeMap: newMap\n                };\n                // Otherwise, update the parent node and its ancestors.\n                return updateTree(items, parentKey, (parentNode)=>({\n                        key: parentNode.key,\n                        parentKey: parentNode.parentKey,\n                        value: parentNode.value,\n                        children: [\n                            ...parentNode.children.slice(0, index),\n                            ...newNodes,\n                            ...parentNode.children.slice(index)\n                        ]\n                    }), newMap);\n            });\n        },\n        insertBefore (key, ...values) {\n            let node = nodeMap.get(key);\n            if (!node) return;\n            let parentNode = nodeMap.get(node.parentKey);\n            let nodes = parentNode ? parentNode.children : items;\n            let index = nodes.indexOf(node);\n            this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);\n        },\n        insertAfter (key, ...values) {\n            let node = nodeMap.get(key);\n            if (!node) return;\n            let parentNode = nodeMap.get(node.parentKey);\n            let nodes = parentNode ? parentNode.children : items;\n            let index = nodes.indexOf(node);\n            this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);\n        },\n        prepend (parentKey, ...values) {\n            this.insert(parentKey, 0, ...values);\n        },\n        append (parentKey, ...values) {\n            if (parentKey == null) this.insert(null, items.length, ...values);\n            else {\n                let parentNode = nodeMap.get(parentKey);\n                if (!parentNode) return;\n                this.insert(parentKey, parentNode.children.length, ...values);\n            }\n        },\n        remove (...keys) {\n            if (keys.length === 0) return;\n            let newItems = items;\n            let prevMap = nodeMap;\n            let newTree;\n            for (let key of keys){\n                newTree = updateTree(newItems, key, ()=>null, prevMap);\n                prevMap = newTree.nodeMap;\n                newItems = newTree.items;\n            }\n            setItems(newTree);\n            let selection = new Set(selectedKeys);\n            for (let key of selectedKeys)if (!newTree.nodeMap.has(key)) selection.delete(key);\n            setSelectedKeys(selection);\n        },\n        removeSelectedItems () {\n            this.remove(...selectedKeys);\n        },\n        move (key, toParentKey, index) {\n            setItems(({ items: items, nodeMap: originalMap })=>{\n                let node = originalMap.get(key);\n                if (!node) return {\n                    items: items,\n                    nodeMap: originalMap\n                };\n                let { items: newItems, nodeMap: newMap } = updateTree(items, key, ()=>null, originalMap);\n                const movedNode = {\n                    ...node,\n                    parentKey: toParentKey\n                };\n                // If parentKey is null, insert into the root.\n                if (toParentKey == null) {\n                    newMap.set(movedNode.key, movedNode);\n                    return {\n                        items: [\n                            ...newItems.slice(0, index),\n                            movedNode,\n                            ...newItems.slice(index)\n                        ],\n                        nodeMap: newMap\n                    };\n                }\n                // Otherwise, update the parent node and its ancestors.\n                return updateTree(newItems, toParentKey, (parentNode)=>({\n                        key: parentNode.key,\n                        parentKey: parentNode.parentKey,\n                        value: parentNode.value,\n                        children: [\n                            ...parentNode.children.slice(0, index),\n                            movedNode,\n                            ...parentNode.children.slice(index)\n                        ]\n                    }), newMap);\n            });\n        },\n        update (oldKey, newValue) {\n            setItems(({ items: items, nodeMap: originalMap })=>updateTree(items, oldKey, (oldNode)=>{\n                    let node = {\n                        key: oldNode.key,\n                        parentKey: oldNode.parentKey,\n                        value: newValue,\n                        children: null\n                    };\n                    let tree = buildTree(getChildren(newValue), originalMap, node.key);\n                    node.children = tree.items;\n                    return node;\n                }, originalMap));\n        }\n    };\n}\n\n\nexport {$be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData};\n//# sourceMappingURL=useTreeData.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}